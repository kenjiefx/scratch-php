{
  "title": "Hello, Scratch!",
  "template": "index",
  "data": {
    "content": "<h1>Scratch PHP</h1>\n<h3 id=\"introduction\">Introduction</h3>\n<p>ScratchPHP is a simple, lightweight, and endlessly extendable static site generator. Its goal is to provide developers with an easy and maintainable way to build static websites, leveraging the power and flexibility of PHP’s templating engine.</p>\n<h5>No Parsers, No Hassle</h5>\n<p>ScratchPHP takes advantage of PHP itself being a templating engine—no custom templating DSL, no parsing libraries. This library relies on simple APIs which are PHP functions themselves, reducing dependencies and eliminating unnecessary overhead.\nThis approach keeps ScratchPHP lightweight while still providing the flexibility and power needed to build dynamic static content efficiently.</p>\n<h3 id=\"getting_started\">Getting Started</h3>\n<p>The simplest way to get started with Scratch PHP is to create a project using Scratch Skeleton by running this command:</p>\n<pre><code class=\"language-bash\">composer create-project kenjiefx/scratch-skeleton &lt;app name&gt;\n</code></pre>\n<p>Everything you need to get started is included in the skeleton repository. It comes with a built-in development server, allowing you to preview your site instantly—no need to manually run the <code>build</code> command during development.</p>\n<pre><code class=\"language-bash\">php -S 127.0.0.1:7743 server.php\n</code></pre>\n<blockquote>\n<p><em><strong>Note:</strong></em> While the built-in server is powered by the Slim PHP framework—a robust, production-ready framework—it’s highly recommended to use a server that serves static files directly. Routing traffic through <code>server.php</code> in production defeats the purpose of ScratchPHP, which is to generate static sites.</p>\n</blockquote>\n<h3 id=\"application_life_cycle\">Application Life Cycle</h3>\n<p>ScratchPHP begins with the instantiation of <code>Kenjiefx\\ScratchPHP\\App()</code>, which detects the runtime context—either CLI or HTTP—and instantiates the appropriate app runner interface. Depending on the context, the CLI runner handles terminal commands, while the HTTP runner manages web requests, both adhering to a common interface with environment-specific implementations.</p>\n<p>Before reaching the service layer, extensions are registered once per execution cycle by the Extension Manager. Early in the lifecycle, service providers are delegated based on the specific CLI command or HTTP route.</p>\n<p>Finally, the Build Service orchestrates the build process and hands off the export of static pages and assets to an export provider.</p>\n",
    "updatedAt": 1752498269004
  }
}